# å¸‚åœºæ“çºµæ£€æµ‹ç­–ç•¥ - å®Œæ•´æŠ€æœ¯æ–‡æ¡£

**ç‰ˆæœ¬**: 1.0  
**æ—¥æœŸ**: 2025-11-16  
**ç›®çš„**: æä¾›å®Œæ•´çš„ç­–ç•¥å¤ç°æŒ‡å—

---

## ç›®å½•

1. [ç­–ç•¥æ¦‚è¿°](#ç­–ç•¥æ¦‚è¿°)
2. [æ•°æ®è¦æ±‚](#æ•°æ®è¦æ±‚)
3. [ç‰¹å¾å·¥ç¨‹](#ç‰¹å¾å·¥ç¨‹)
4. [ä¿¡å·ç”Ÿæˆ](#ä¿¡å·ç”Ÿæˆ)
5. [å›æµ‹å¼•æ“](#å›æµ‹å¼•æ“)
6. [å‚æ•°é…ç½®](#å‚æ•°é…ç½®)
7. [å®Œæ•´ä»£ç ç¤ºä¾‹](#å®Œæ•´ä»£ç ç¤ºä¾‹)
8. [éªŒè¯æ–¹æ³•](#éªŒè¯æ–¹æ³•)

---

## ç­–ç•¥æ¦‚è¿°

### æ ¸å¿ƒæ€æƒ³

**å¸‚åœºæ“çºµæ£€æµ‹ç­–ç•¥**åŸºäºä»¥ä¸‹å‡è®¾ï¼š
1. å¸‚åœºå­˜åœ¨æ“çºµè¡Œä¸ºï¼Œè¡¨ç°ä¸ºå¾®è§‚ç»“æ„å¼‚å¸¸
2. æ“çºµåçš„ä»·æ ¼ä¼šå‡ºç°åè½¬æˆ–å»¶ç»­
3. é€šè¿‡æ£€æµ‹å¼‚å¸¸å¹¶ç»“åˆè¶‹åŠ¿æ–¹å‘ï¼Œå¯ä»¥é¢„æµ‹æœªæ¥èµ°åŠ¿

### ç­–ç•¥ç±»å‹

**éå¯¹ç§°ç­–ç•¥**ï¼ˆAsymmetric Strategyï¼‰:
- **æç«¯ä¸Šæ¶¨** + é«˜æ“çºµåˆ†æ•° â†’ **åšå¤š**ï¼ˆå»¶ç»­ï¼‰
- **æç«¯ä¸‹è·Œ** + é«˜æ“çºµåˆ†æ•° â†’ **åšå¤š**ï¼ˆåè½¬ï¼‰

**å…³é”®**: ä¸¤ä¸ªæ–¹å‘éƒ½æ˜¯åšå¤šï¼Œåˆ©ç”¨ä¸åŒçš„å¸‚åœºåŠ¨åŠ›å­¦

---

## æ•°æ®è¦æ±‚

### ğŸ¯ å®ç›˜æ•°æ®éœ€æ±‚ï¼ˆé‡è¦ï¼‰

**å¯¹äº60åˆ†é’Ÿå’Œ4å°æ—¶ç­–ç•¥ï¼Œåªéœ€è¦Kçº¿æ•°æ®å³å¯ï¼**

#### âœ… æ¨èæ–¹æ¡ˆï¼šä»…ä½¿ç”¨Kçº¿æ•°æ®

**ä¼˜ç‚¹**:
- âœ… ç®€å•æ˜“è·å–ï¼ˆæ‰€æœ‰äº¤æ˜“æ‰€APIéƒ½æä¾›ï¼‰
- âœ… æ•°æ®é‡å°ï¼Œæ˜“äºå­˜å‚¨å’Œå¤„ç†
- âœ… å»¶è¿Ÿä½ï¼Œé€‚åˆå®ç›˜
- âœ… ManipScoreè´¨é‡ä»ç„¶è‰¯å¥½ï¼ˆä½¿ç”¨æ»åæ”¶ç›Šä½œä¸ºç‰¹å¾ï¼‰

**é€‚ç”¨åœºæ™¯**:
- 60åˆ†é’Ÿç­–ç•¥ï¼ˆæ¯2.5å¤©ä¸€ç¬”äº¤æ˜“ï¼‰
- 4å°æ—¶ç­–ç•¥ï¼ˆæ¯11.5å¤©ä¸€ç¬”äº¤æ˜“ï¼‰
- æ‰€æœ‰ä¸­ä½é¢‘ç­–ç•¥

#### âš ï¸ å¯é€‰æ–¹æ¡ˆï¼šä½¿ç”¨Tickæ•°æ®

**ä¼˜ç‚¹**:
- âœ… ManipScoreè´¨é‡æœ€é«˜ï¼ˆåŒ…å«å¾®è§‚ç»“æ„ä¿¡æ¯ï¼‰
- âœ… ä¸å›æµ‹å®Œå…¨ä¸€è‡´

**ç¼ºç‚¹**:
- âŒ æ•°æ®é‡å¤§ï¼ˆæ¯å¤©æ•°ç™¾ä¸‡æ¡tickï¼‰
- âŒ éœ€è¦å®æ—¶å¤„ç†
- âŒ å¤§å¤šæ•°äº¤æ˜“æ‰€APIæœ‰é™åˆ¶

**é€‚ç”¨åœºæ™¯**:
- é«˜é¢‘ç­–ç•¥ï¼ˆ5åˆ†é’Ÿã€15åˆ†é’Ÿï¼‰
- éœ€è¦æœ€é«˜ç²¾åº¦çš„åœºæ™¯

---

### è¾“å…¥æ•°æ®æ ¼å¼

#### æ–¹æ¡ˆAï¼šKçº¿æ•°æ®ï¼ˆæ¨èï¼‰â­

```python
# æœ€ä½è¦æ±‚ï¼šOHLCæ•°æ®
bars = pd.DataFrame({
    'timestamp': [...],  # datetime
    'open': [...],       # float
    'high': [...],       # float
    'low': [...],        # float
    'close': [...],      # float
    'volume': [...]      # float (å¯é€‰)
})
```

**ç¤ºä¾‹**:
```
æ—¶é—´æˆ³, open, high, low, close, volume
2017-05-07 00:00:00, 1580.50, 1582.00, 1579.00, 1581.50, 1000
2017-05-07 01:00:00, 1581.50, 1583.00, 1580.50, 1582.00, 1200
...
```

#### æ–¹æ¡ˆBï¼šTickæ•°æ®ï¼ˆå¯é€‰ï¼‰

```python
# Tickçº§åˆ«æ•°æ®
ticks = pd.DataFrame({
    'timestamp': [...],  # datetime
    'bid': [...],        # float
    'ask': [...],        # float
    'volume': [...]      # float (å¯é€‰)
})
```

**ç¤ºä¾‹**:
```
æ—¶é—´æˆ³, bid, ask
2017-05-07 00:00:00, 1580.50, 1580.75
2017-05-07 00:00:01, 1580.55, 1580.80
...
```

---

### æ•°æ®å­—æ®µè¯´æ˜

| å­—æ®µ | ç±»å‹ | è¯´æ˜ | Kçº¿æ–¹æ¡ˆ | Tickæ–¹æ¡ˆ |
|------|------|------|---------|---------|
| timestamp | datetime | æ—¶é—´æˆ³ï¼ˆUTCï¼‰ | âœ… å¿…éœ€ | âœ… å¿…éœ€ |
| open | float | å¼€ç›˜ä»· | âœ… å¿…éœ€ | âŒ |
| high | float | æœ€é«˜ä»· | âœ… å¿…éœ€ | âŒ |
| low | float | æœ€ä½ä»· | âœ… å¿…éœ€ | âŒ |
| close | float | æ”¶ç›˜ä»· | âœ… å¿…éœ€ | âŒ |
| volume | float | æˆäº¤é‡ | â­ æ¨è | â­ æ¨è |
| bid | float | ä¹°ä»· | âŒ | âœ… å¿…éœ€ |
| ask | float | å–ä»· | âŒ | âœ… å¿…éœ€ |

### æ•°æ®è´¨é‡è¦æ±‚

1. **æ—¶é—´è¿ç»­æ€§**: æ— å¤§æ®µç¼ºå¤±
2. **ä»·æ ¼åˆç†æ€§**: æ— å¼‚å¸¸è·³å˜
3. **ç²¾åº¦**: è‡³å°‘4ä½å°æ•°
4. **æ—¶åŒº**: ç»Ÿä¸€ä½¿ç”¨UTC
5. **å†å²æ•°æ®é‡**: è‡³å°‘1000ä¸ªbarï¼ˆç”¨äºè®­ç»ƒManipScoreæ¨¡å‹ï¼‰

---

## ç‰¹å¾å·¥ç¨‹

### ç¬¬ä¸€æ­¥ï¼šæ„å»ºBaræ•°æ®

#### ä»Tickæ•°æ®æ„å»º5åˆ†é’ŸBar

**ç®—æ³•**:
```python
def build_bars_from_ticks(ticks, bar_size='5min'):
    """
    ä»tickæ•°æ®æ„å»ºbar
    
    å‚æ•°:
        ticks: DataFrame with columns [timestamp, bid, ask]
        bar_size: '5min', '15min', '30min', '60min', '4h', '1d'
    
    è¿”å›:
        bars: DataFrame with columns [timestamp, open, high, low, close, volume]
    """
    # 1. è®¡ç®—ä¸­é—´ä»·
    ticks['mid'] = (ticks['bid'] + ticks['ask']) / 2
    
    # 2. è®¾ç½®æ—¶é—´ç´¢å¼•
    ticks.set_index('timestamp', inplace=True)
    
    # 3. é‡é‡‡æ ·
    bars = ticks['mid'].resample(bar_size).agg({
        'open': 'first',
        'high': 'max',
        'low': 'min',
        'close': 'last',
        'volume': 'count'  # tickæ•°é‡ä½œä¸ºvolume
    })
    
    # 4. åˆ é™¤ç¼ºå¤±å€¼
    bars = bars.dropna()
    
    return bars
```

**ç¤ºä¾‹**:
```
è¾“å…¥Tick:
2017-05-07 00:00:00, bid=1580.50, ask=1580.75 â†’ mid=1580.625
2017-05-07 00:00:30, bid=1580.60, ask=1580.85 â†’ mid=1580.725
2017-05-07 00:01:00, bid=1580.55, ask=1580.80 â†’ mid=1580.675
...
2017-05-07 00:04:30, bid=1581.00, ask=1581.25 â†’ mid=1581.125

è¾“å‡ºBar (5min):
2017-05-07 00:00:00, open=1580.625, high=1581.125, low=1580.500, close=1581.125, volume=300
```

---

### ç¬¬äºŒæ­¥ï¼šè®¡ç®—åŸºç¡€ç‰¹å¾

#### 2.1 å¯¹æ•°æ”¶ç›Šç‡

**å…¬å¼**:
```
log_return[t] = ln(close[t] / close[t-1])
```

**ä»£ç **:
```python
bars['log_return'] = np.log(bars['close'] / bars['close'].shift(1))
```

**ç¤ºä¾‹**:
```
close[t-1] = 1580.00
close[t] = 1585.00
log_return[t] = ln(1585.00 / 1580.00) = ln(1.00316) = 0.003155 (0.3155%)
```

---

#### 2.2 æ»šåŠ¨æ³¢åŠ¨ç‡ (Sigma)

**å…¬å¼**:
```
sigma[t] = std(log_return[t-vol_window+1 : t])
```

**å‚æ•°**:
- `vol_window`: é»˜è®¤20ä¸ªbar

**ä»£ç **:
```python
def compute_volatility(bars, vol_window=20):
    """è®¡ç®—æ»šåŠ¨æ³¢åŠ¨ç‡"""
    bars['sigma'] = bars['log_return'].rolling(window=vol_window).std()
    
    # å‰å‘å¡«å……ç¼ºå¤±å€¼
    bars['sigma'] = bars['sigma'].ffill()
    
    # å¦‚æœä»æœ‰ç¼ºå¤±ï¼Œä½¿ç”¨å…¨å±€æ ‡å‡†å·®
    if bars['sigma'].isna().any():
        bars['sigma'] = bars['sigma'].fillna(bars['log_return'].std())
    
    return bars
```

**ç¤ºä¾‹**:
```
å‡è®¾vol_window=20
log_return[-19:0] = [0.001, -0.002, 0.003, ..., 0.001]
sigma[0] = std([0.001, -0.002, 0.003, ..., 0.001]) = 0.015 (1.5%)
```

---

#### 2.3 è¶‹åŠ¿å¼ºåº¦ (Trend Strength, TS)

**å…¬å¼**:
```
R_past[t] = sum(log_return[t-L_past+1 : t])
TS[t] = R_past[t] / sigma[t]
```

**å‚æ•°**:
- `L_past`: å›çœ‹çª—å£ï¼Œé»˜è®¤5ä¸ªbar

**ä»£ç **:
```python
def compute_trend_strength(bars, L_past=5, vol_window=20):
    """
    è®¡ç®—è¶‹åŠ¿å¼ºåº¦
    
    å‚æ•°:
        bars: DataFrame with 'close' column
        L_past: å›çœ‹çª—å£
        vol_window: æ³¢åŠ¨ç‡çª—å£
    
    è¿”å›:
        bars: æ·»åŠ äº† 'log_return', 'sigma', 'R_past', 'TS' åˆ—
    """
    # 1. è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡
    bars['log_return'] = np.log(bars['close'] / bars['close'].shift(1))
    
    # 2. è®¡ç®—æ³¢åŠ¨ç‡
    bars['sigma'] = bars['log_return'].rolling(window=vol_window).std()
    bars['sigma'] = bars['sigma'].ffill().fillna(bars['log_return'].std())
    
    # 3. è®¡ç®—ç´¯è®¡æ”¶ç›Š
    bars['R_past'] = bars['log_return'].rolling(window=L_past).sum()
    
    # 4. è®¡ç®—è¶‹åŠ¿å¼ºåº¦
    bars['TS'] = bars['R_past'] / bars['sigma']
    
    return bars
```

**ç¤ºä¾‹**:
```
å‡è®¾L_past=5, vol_window=20

æ—¶åˆ»tçš„å‰5ä¸ªbarçš„log_return:
[0.002, 0.003, -0.001, 0.004, 0.002]

R_past[t] = 0.002 + 0.003 - 0.001 + 0.004 + 0.002 = 0.010 (1.0%)
sigma[t] = 0.015 (1.5%)
TS[t] = 0.010 / 0.015 = 0.667
```

**è§£é‡Š**:
- TS > 0: ä¸Šæ¶¨è¶‹åŠ¿
- TS < 0: ä¸‹è·Œè¶‹åŠ¿
- |TS| è¶Šå¤§ï¼Œè¶‹åŠ¿è¶Šå¼º

---

### ç¬¬ä¸‰æ­¥ï¼šè®¡ç®—æ“çºµåˆ†æ•° (ManipScore)

#### 3.1 åŸºå‡†å›å½’æ¨¡å‹

**ç›®çš„**: å»ºç«‹ä»·æ ¼å˜åŒ–çš„åŸºå‡†æ¨¡å‹

**å›å½’æ–¹ç¨‹**:
```
abs_ret[t] = Î± + Î²â‚ * R_past[t] + Î²â‚‚ * sigma[t] + Îµ[t]
```

å…¶ä¸­:
- `abs_ret[t]`: å½“å‰barçš„ç»å¯¹æ”¶ç›Š |log_return[t]|
- `R_past[t]`: è¿‡å»L_pastä¸ªbarçš„ç´¯è®¡æ”¶ç›Š
- `sigma[t]`: å½“å‰æ³¢åŠ¨ç‡
- `Îµ[t]`: æ®‹å·®ï¼ˆå¼‚å¸¸éƒ¨åˆ†ï¼‰

âš ï¸ **é‡è¦**: ä½¿ç”¨å½“å‰barçš„ç»å¯¹æ”¶ç›Šè€Œä¸æ˜¯æœªæ¥æ”¶ç›Šï¼Œé¿å…å‰è§†åå·®

**å‚æ•°**:
- `L_past`: é»˜è®¤5
- `L_future`: é»˜è®¤5

**ä»£ç **:
```python
def fit_manipscore_model(bars, L_past=5, L_future=5, vol_window=20):
    """
    æ‹ŸåˆManipScoreæ¨¡å‹

    âš ï¸ é‡è¦: ä½¿ç”¨å½“å‰barçš„ç»å¯¹æ”¶ç›Šä½œä¸ºç›®æ ‡ï¼Œé¿å…å‰è§†åå·®

    æ­¥éª¤:
    1. è®¡ç®—R_pastå’Œsigma (è¿‡å»æ•°æ®)
    2. çº¿æ€§å›å½’: abs_ret ~ R_past + sigma
    3. è®¡ç®—æ®‹å·®
    4. æ ‡å‡†åŒ–æ®‹å·®å¾—åˆ°ManipScore
    """
    from sklearn.linear_model import LinearRegression

    # 1. è®¡ç®—ç‰¹å¾
    bars = compute_trend_strength(bars, L_past, vol_window)

    # 2. âœ… è®¡ç®—å½“å‰barçš„ç»å¯¹æ”¶ç›Š (ä¸ä½¿ç”¨æœªæ¥æ•°æ®)
    bars['abs_ret'] = bars['log_return'].abs()

    # 3. å‡†å¤‡å›å½’æ•°æ®
    valid_mask = bars[['R_past', 'sigma', 'abs_ret']].notna().all(axis=1)
    X = bars.loc[valid_mask, ['R_past', 'sigma']].values
    y = bars.loc[valid_mask, 'abs_ret'].values  # âœ… ä½¿ç”¨å½“å‰barçš„ç»å¯¹æ”¶ç›Š

    # 4. æ‹Ÿåˆçº¿æ€§å›å½’
    model = LinearRegression()
    model.fit(X, y)

    # 5. è®¡ç®—æ®‹å·®
    y_pred = model.predict(X)
    residuals = y - y_pred

    # 6. æ ‡å‡†åŒ–æ®‹å·® â†’ ManipScore
    manip_score = (residuals - residuals.mean()) / residuals.std()

    # 7. å¡«å……åˆ°åŸå§‹DataFrame
    bars.loc[valid_mask, 'ManipScore'] = manip_score
    bars['ManipScore'] = bars['ManipScore'].fillna(0)

    return bars, model
```

**ç¤ºä¾‹**:
```
å‡è®¾æŸä¸ªæ—¶åˆ»t:
R_past[t] = 0.010 (1.0%)
sigma[t] = 0.015 (1.5%)
abs_ret[t] = 0.025 (2.5%)  # å½“å‰barçš„ç»å¯¹æ”¶ç›Š

å›å½’æ¨¡å‹é¢„æµ‹:
abs_ret_pred[t] = Î± + Î²â‚ * 0.010 + Î²â‚‚ * 0.015
                = 0.005 + 0.3 * 0.010 + 0.5 * 0.015
                = 0.005 + 0.003 + 0.0075
                = 0.0155 (1.55%)

æ®‹å·®:
residual[t] = abs_ret[t] - abs_ret_pred[t]
            = 0.025 - 0.0155
            = 0.0095 (0.95%)

æ ‡å‡†åŒ–æ®‹å·® (å‡è®¾std=0.005):
ManipScore[t] = (0.0095 - 0) / 0.005 = 1.9
```

**è§£é‡Š**:
- ManipScore > 0: å½“å‰æ³¢åŠ¨é«˜äºé¢„æœŸï¼ˆå¯èƒ½æœ‰å¼‚å¸¸æ´»åŠ¨ï¼‰
- ManipScore < 0: å½“å‰æ³¢åŠ¨ä½äºé¢„æœŸï¼ˆå¸‚åœºå¹³é™ï¼‰
- |ManipScore| è¶Šå¤§ï¼Œå¼‚å¸¸ç¨‹åº¦è¶Šé«˜

---

#### 3.2 ManipScoreçš„ç‰©ç†æ„ä¹‰

**ManipScoreè¡¡é‡çš„æ˜¯**:
- ä»·æ ¼å˜åŒ–ä¸­**æ— æ³•ç”¨å†å²è¶‹åŠ¿å’Œæ³¢åŠ¨ç‡è§£é‡Šçš„éƒ¨åˆ†**
- å¯èƒ½æ¥æºäºï¼š
  - å¸‚åœºæ“çºµ
  - çªå‘æ–°é—»
  - å¤§é¢è®¢å•
  - æµåŠ¨æ€§å†²å‡»

**ä¸ºä»€ä¹ˆæœ‰æ•ˆ**:
- æ“çºµè¡Œä¸ºä¼šåœ¨å¾®è§‚ç»“æ„ä¸­ç•™ä¸‹ç—•è¿¹
- è¿™äº›ç—•è¿¹è¡¨ç°ä¸º"å¼‚å¸¸"çš„ä»·æ ¼å˜åŒ–
- ManipScoreæ•æ‰è¿™ç§å¼‚å¸¸

---

### ç¬¬å››æ­¥ï¼šè¯†åˆ«æç«¯è¶‹åŠ¿

#### 4.1 è®¡ç®—æç«¯é˜ˆå€¼

**æ–¹æ³•**: ä½¿ç”¨åˆ†ä½æ•°

**å…¬å¼**:
```
threshold = quantile(|TS|, q_extreme_trend)
```

**å‚æ•°**:
- `q_extreme_trend`: é»˜è®¤0.9ï¼ˆ90%åˆ†ä½æ•°ï¼‰

**ä»£ç **:
```python
def compute_extreme_trend_thresholds(bars, quantile=0.9):
    """
    è®¡ç®—æç«¯è¶‹åŠ¿é˜ˆå€¼
    
    å‚æ•°:
        bars: DataFrame with 'TS' column
        quantile: åˆ†ä½æ•°ï¼Œé»˜è®¤0.9
    
    è¿”å›:
        dict: {'threshold': float}
    """
    threshold = bars['TS'].abs().quantile(quantile)
    return {'threshold': threshold}
```

**ç¤ºä¾‹**:
```
å‡è®¾TSçš„åˆ†å¸ƒ:
TS = [-2.5, -1.8, -0.5, 0.3, 0.8, 1.2, 1.5, 2.0, 2.3, 2.8]
|TS| = [2.5, 1.8, 0.5, 0.3, 0.8, 1.2, 1.5, 2.0, 2.3, 2.8]

90%åˆ†ä½æ•°:
threshold = quantile(|TS|, 0.9) = 2.5

æç«¯ä¸Šæ¶¨: TS > 2.5
æç«¯ä¸‹è·Œ: TS < -2.5
```

---

#### 4.2 è¯†åˆ«æç«¯è¶‹åŠ¿

**æ¡ä»¶**:
```
æç«¯ä¸Šæ¶¨: TS[t] > threshold
æç«¯ä¸‹è·Œ: TS[t] < -threshold
```

**ä»£ç **:
```python
def identify_extreme_trends(bars, threshold):
    """
    è¯†åˆ«æç«¯è¶‹åŠ¿
    
    è¿”å›:
        bars: æ·»åŠ äº† 'extreme_up', 'extreme_down' åˆ—
    """
    bars['extreme_up'] = bars['TS'] > threshold
    bars['extreme_down'] = bars['TS'] < -threshold
    
    return bars
```

---

### ç¬¬äº”æ­¥ï¼šè¯†åˆ«é«˜æ“çºµåˆ†æ•°

**æ–¹æ³•**: ä½¿ç”¨åˆ†ä½æ•°

**å…¬å¼**:
```
manip_threshold = quantile(ManipScore, q_manip)
```

**å‚æ•°**:
- `q_manip`: é»˜è®¤0.9ï¼ˆ90%åˆ†ä½æ•°ï¼‰

**ä»£ç **:
```python
def identify_high_manip(bars, quantile=0.9):
    """
    è¯†åˆ«é«˜æ“çºµåˆ†æ•°
    
    è¿”å›:
        bars: æ·»åŠ äº† 'high_manip' åˆ—
    """
    manip_threshold = bars['ManipScore'].quantile(quantile)
    bars['high_manip'] = bars['ManipScore'] > manip_threshold
    
    return bars
```

**ç¤ºä¾‹**:
```
å‡è®¾ManipScoreçš„åˆ†å¸ƒ:
ManipScore = [-1.5, -0.8, 0.2, 0.5, 0.9, 1.2, 1.5, 1.8, 2.1, 2.5]

90%åˆ†ä½æ•°:
manip_threshold = quantile(ManipScore, 0.9) = 2.1

é«˜æ“çºµ: ManipScore > 2.1
```

---

## ä¿¡å·ç”Ÿæˆ

### éå¯¹ç§°ç­–ç•¥ä¿¡å·è§„åˆ™

**è§„åˆ™**:
```
ä¿¡å·[t] = 1 (åšå¤š) å½“:
    (æç«¯ä¸Šæ¶¨[t] AND é«˜æ“çºµ[t]) OR (æç«¯ä¸‹è·Œ[t] AND é«˜æ“çºµ[t])

ä¿¡å·[t] = 0 (ä¸äº¤æ˜“) å…¶ä»–æƒ…å†µ
```

**å…³é”®**: 
- æç«¯ä¸Šæ¶¨ + é«˜æ“çºµ â†’ åšå¤šï¼ˆå»¶ç»­ç­–ç•¥ï¼‰
- æç«¯ä¸‹è·Œ + é«˜æ“çºµ â†’ åšå¤šï¼ˆåè½¬ç­–ç•¥ï¼‰

**ä»£ç **:
```python
def generate_asymmetric_signals(bars, config):
    """
    ç”Ÿæˆéå¯¹ç§°ç­–ç•¥ä¿¡å·
    
    å‚æ•°:
        bars: DataFrame with ManipScore
        config: ExtremeReversalConfigå¯¹è±¡
    
    è¿”å›:
        signals: DataFrame with 'signal' column
    """
    # 1. è®¡ç®—è¶‹åŠ¿å¼ºåº¦
    bars = compute_trend_strength(
        bars, 
        L_past=config.L_past, 
        vol_window=config.vol_window
    )
    
    # 2. è®¡ç®—æç«¯é˜ˆå€¼
    thresholds = compute_extreme_trend_thresholds(
        bars, 
        quantile=config.q_extreme_trend
    )
    threshold = thresholds['threshold']
    
    # 3. è¯†åˆ«æç«¯è¶‹åŠ¿
    extreme_up = bars['TS'] > threshold
    extreme_down = bars['TS'] < -threshold
    
    # 4. è¯†åˆ«é«˜æ“çºµ
    manip_threshold = bars['ManipScore'].quantile(config.q_manip)
    high_manip = bars['ManipScore'] > manip_threshold
    
    # 5. ç”Ÿæˆä¿¡å·
    signals = pd.DataFrame(index=bars.index)
    signals['signal'] = 0
    
    # æç«¯ä¸Šæ¶¨ + é«˜æ“çºµ â†’ åšå¤š
    signals.loc[extreme_up & high_manip, 'signal'] = 1
    
    # æç«¯ä¸‹è·Œ + é«˜æ“çºµ â†’ åšå¤š
    signals.loc[extreme_down & high_manip, 'signal'] = 1
    
    # 6. ä¿¡å·å»¶è¿Ÿä¸€ä¸ªbarï¼ˆé¿å…å‰è§†åå·®ï¼‰
    signals['signal'] = signals['signal'].shift(1).fillna(0)
    
    return signals
```

**ç¤ºä¾‹**:
```
æ—¶åˆ»t:
TS[t] = 2.8 > threshold(2.5) â†’ æç«¯ä¸Šæ¶¨ = True
ManipScore[t] = 2.3 > manip_threshold(2.1) â†’ é«˜æ“çºµ = True

ä¿¡å·[t+1] = 1 (åšå¤š)

æ—¶åˆ»t+1:
åœ¨t+1çš„å¼€ç›˜ä»·ä¹°å…¥
```

---

## å›æµ‹å¼•æ“

### äº¤æ˜“æ‰§è¡Œé€»è¾‘

#### å…¥åœºè§„åˆ™

**æ¡ä»¶**:
```
å½“å‰æ— æŒä»“ AND ä¿¡å·[t] == 1
```

**æ‰§è¡Œ**:
```
åœ¨bar[t]çš„æ”¶ç›˜ä»·ä¹°å…¥
è®°å½•å…¥åœºæ—¶é—´ã€å…¥åœºä»·æ ¼
è®¡ç®—æ­¢æŸä»·å’Œæ­¢ç›ˆä»·ï¼ˆå¦‚æœä½¿ç”¨ï¼‰
```

**ä»£ç **:
```python
# å…¥åœº
if position is None and signal[t] == 1:
    entry_price = bars['close'][t]
    entry_time = bars.index[t]
    direction = 1  # åšå¤š
    
    # è®¡ç®—æ­¢æŸæ­¢ç›ˆä»·æ ¼
    atr = compute_atr(bars, window=config.atr_window)
    sl_price = entry_price - config.sl_atr_mult * atr[t]
    tp_price = entry_price + config.tp_atr_mult * atr[t]
    
    position = Trade(
        entry_time=entry_time,
        entry_price=entry_price,
        direction=direction,
        sl_price=sl_price,
        tp_price=tp_price
    )
```

---

#### å‡ºåœºè§„åˆ™

**ä¼˜å…ˆçº§**ï¼ˆä»é«˜åˆ°ä½ï¼‰:

1. **æ­¢æŸè§¦å‘**:
```
å½“å‰ä»·æ ¼ <= æ­¢æŸä»·
```

2. **æ­¢ç›ˆè§¦å‘**:
```
å½“å‰ä»·æ ¼ >= æ­¢ç›ˆä»·
```

3. **æ—¶é—´æ­¢æŸ**:
```
æŒä»“æ—¶é—´ >= holding_horizon
```

4. **åå‘ä¿¡å·**:
```
ä¿¡å·[t] == -1 (å¦‚æœæœ‰åšç©ºä¿¡å·)
```

**ä»£ç **:
```python
# å‡ºåœºæ£€æŸ¥
if position is not None:
    current_price = bars['close'][t]
    bars_held = t - position.entry_bar
    
    exit_reason = None
    
    # 1. æ£€æŸ¥æ­¢æŸ
    if current_price <= position.sl_price:
        exit_reason = 'SL'
        exit_price = position.sl_price
    
    # 2. æ£€æŸ¥æ­¢ç›ˆ
    elif current_price >= position.tp_price:
        exit_reason = 'TP'
        exit_price = position.tp_price
    
    # 3. æ£€æŸ¥æ—¶é—´æ­¢æŸ
    elif bars_held >= config.holding_horizon:
        exit_reason = 'TIME'
        exit_price = current_price
    
    # æ‰§è¡Œå‡ºåœº
    if exit_reason:
        # è®¡ç®—æ”¶ç›Š
        pnl_pct = (exit_price - position.entry_price) / position.entry_price
        
        # æ‰£é™¤äº¤æ˜“æˆæœ¬
        pnl_pct -= config.cost_per_trade
        
        # æ›´æ–°æƒç›Š
        position.exit_time = bars.index[t]
        position.exit_price = exit_price
        position.exit_reason = exit_reason
        position.pnl_pct = pnl_pct
        position.pnl = equity * pnl_pct
        
        equity += position.pnl
        
        # è®°å½•äº¤æ˜“
        trades.append(position)
        position = None
```

---

### ATRè®¡ç®—

**å…¬å¼**:
```
TR[t] = max(high[t] - low[t], 
            |high[t] - close[t-1]|, 
            |low[t] - close[t-1]|)

ATR[t] = mean(TR[t-window+1 : t])
```

**ä»£ç **:
```python
def compute_atr(bars, window=10):
    """
    è®¡ç®—ATR (Average True Range)
    
    å‚æ•°:
        bars: DataFrame with 'high', 'low', 'close'
        window: ATRçª—å£ï¼Œé»˜è®¤10
    
    è¿”å›:
        atr: Series
    """
    # è®¡ç®—True Range
    high_low = bars['high'] - bars['low']
    high_close = (bars['high'] - bars['close'].shift(1)).abs()
    low_close = (bars['low'] - bars['close'].shift(1)).abs()
    
    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    
    # è®¡ç®—ATR
    atr = tr.rolling(window=window).mean()
    
    return atr
```

**ç¤ºä¾‹**:
```
å‡è®¾window=10

bar[t]:
high = 1585.00
low = 1580.00
close[t-1] = 1582.00

TR[t] = max(1585.00 - 1580.00,  # 5.00
            |1585.00 - 1582.00|,  # 3.00
            |1580.00 - 1582.00|)  # 2.00
      = 5.00

ATR[t] = mean(TR[t-9:t]) = mean([4.5, 5.2, 4.8, ..., 5.0]) = 4.9

æ­¢æŸä»· = entry_price - sl_atr_mult * ATR
       = 1582.00 - 0.5 * 4.9
       = 1579.55

æ­¢ç›ˆä»· = entry_price + tp_atr_mult * ATR
       = 1582.00 + 0.8 * 4.9
       = 1585.92
```

---

## å‚æ•°é…ç½®

### å®Œæ•´å‚æ•°åˆ—è¡¨

```python
class ExtremeReversalConfig:
    """ç­–ç•¥é…ç½®å‚æ•°"""
    
    # ===== æ—¶é—´å‘¨æœŸ =====
    bar_size: str = "60min"  # æ¨è: 60minæˆ–4h
    
    # ===== è¶‹åŠ¿å‚æ•° =====
    L_past: int = 5          # å›çœ‹çª—å£ï¼ˆbaræ•°ï¼‰
    vol_window: int = 20     # æ³¢åŠ¨ç‡çª—å£ï¼ˆbaræ•°ï¼‰
    q_extreme_trend: float = 0.9  # æç«¯è¶‹åŠ¿åˆ†ä½æ•°
    
    # ===== æ“çºµæ£€æµ‹å‚æ•° =====
    L_future: int = 5        # å‰ç»çª—å£ï¼ˆbaræ•°ï¼‰
    q_manip: float = 0.9     # é«˜æ“çºµåˆ†ä½æ•°
    
    # ===== æ‰§è¡Œå‚æ•° =====
    holding_horizon: int = 5  # æœ€å¤§æŒä»“æ—¶é—´ï¼ˆbaræ•°ï¼‰
    atr_window: int = 10     # ATRçª—å£ï¼ˆbaræ•°ï¼‰
    sl_atr_mult: float = 0.5 # æ­¢æŸå€æ•°ï¼ˆ0.5å€ATRï¼‰
    tp_atr_mult: float = 0.8 # æ­¢ç›ˆå€æ•°ï¼ˆ0.8å€ATRï¼‰
    cost_per_trade: float = 0.0007  # äº¤æ˜“æˆæœ¬ï¼ˆ0.07%ï¼‰
```

### æ¨èå‚æ•°ç»„åˆ

#### BTC 60åˆ†é’Ÿçº¯å› å­ï¼ˆæœ€ä¼˜ï¼‰

```python
config = ExtremeReversalConfig(
    bar_size="60min",
    L_past=5,
    vol_window=20,
    q_extreme_trend=0.9,
    q_manip=0.9,
    holding_horizon=5,
    atr_window=10,
    sl_atr_mult=999.0,  # ä¸ä½¿ç”¨æ­¢æŸ
    tp_atr_mult=999.0,  # ä¸ä½¿ç”¨æ­¢ç›ˆ
    cost_per_trade=0.0007
)
```

**é¢„æœŸè¡¨ç°**:
- å¹´åŒ–æ”¶ç›Š: 33.25%
- Sharpe: 16.50
- æœ€å¤§å›æ’¤: -31.17%

---

#### ETH 30åˆ†é’Ÿ+æ­¢æŸæ­¢ç›ˆï¼ˆå¹³è¡¡ï¼‰

```python
config = ExtremeReversalConfig(
    bar_size="30min",
    L_past=5,
    vol_window=20,
    q_extreme_trend=0.9,
    q_manip=0.9,
    holding_horizon=5,
    atr_window=10,
    sl_atr_mult=0.5,   # ä½¿ç”¨æ­¢æŸ
    tp_atr_mult=0.8,   # ä½¿ç”¨æ­¢ç›ˆ
    cost_per_trade=0.0007
)
```

**é¢„æœŸè¡¨ç°**:
- å¹´åŒ–æ”¶ç›Š: 27.50%
- Sharpe: 5.20
- æœ€å¤§å›æ’¤: -35.69%

---

#### BTC 4å°æ—¶çº¯å› å­ï¼ˆç¨³å¥ï¼‰

```python
config = ExtremeReversalConfig(
    bar_size="4h",
    L_past=5,
    vol_window=20,
    q_extreme_trend=0.9,
    q_manip=0.9,
    holding_horizon=5,
    atr_window=10,
    sl_atr_mult=999.0,  # ä¸ä½¿ç”¨æ­¢æŸ
    tp_atr_mult=999.0,  # ä¸ä½¿ç”¨æ­¢ç›ˆ
    cost_per_trade=0.0007
)
```

**é¢„æœŸè¡¨ç°**:
- å¹´åŒ–æ”¶ç›Š: 14.87%
- Sharpe: 107.91
- æœ€å¤§å›æ’¤: -35.24%

---

## å®Œæ•´ä»£ç ç¤ºä¾‹

### Pythonå®Œæ•´å®ç°

```python
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from dataclasses import dataclass
from typing import Optional, List

# ===== é…ç½®ç±» =====
@dataclass
class ExtremeReversalConfig:
    bar_size: str = "60min"
    L_past: int = 5
    vol_window: int = 20
    q_extreme_trend: float = 0.9
    L_future: int = 5
    q_manip: float = 0.9
    holding_horizon: int = 5
    atr_window: int = 10
    sl_atr_mult: float = 999.0
    tp_atr_mult: float = 999.0
    cost_per_trade: float = 0.0007

# ===== äº¤æ˜“ç±» =====
@dataclass
class Trade:
    entry_time: pd.Timestamp
    entry_price: float
    direction: int
    exit_time: Optional[pd.Timestamp] = None
    exit_price: Optional[float] = None
    exit_reason: Optional[str] = None
    pnl: Optional[float] = None
    pnl_pct: Optional[float] = None
    sl_price: Optional[float] = None
    tp_price: Optional[float] = None

# ===== ç‰¹å¾å·¥ç¨‹ =====
def compute_trend_strength(bars, L_past=5, vol_window=20):
    """è®¡ç®—è¶‹åŠ¿å¼ºåº¦"""
    bars = bars.copy()
    
    # å¯¹æ•°æ”¶ç›Šç‡
    bars['log_return'] = np.log(bars['close'] / bars['close'].shift(1))
    
    # æ³¢åŠ¨ç‡
    bars['sigma'] = bars['log_return'].rolling(window=vol_window).std()
    bars['sigma'] = bars['sigma'].ffill().fillna(bars['log_return'].std())
    
    # ç´¯è®¡æ”¶ç›Š
    bars['R_past'] = bars['log_return'].rolling(window=L_past).sum()
    
    # è¶‹åŠ¿å¼ºåº¦
    bars['TS'] = bars['R_past'] / bars['sigma']
    
    return bars

def fit_manipscore_model(bars, L_past=5, L_future=5, vol_window=20):
    """æ‹ŸåˆManipScoreæ¨¡å‹"""
    bars = bars.copy()

    # è®¡ç®—ç‰¹å¾
    bars = compute_trend_strength(bars, L_past, vol_window)

    # âœ… è®¡ç®—å½“å‰barçš„ç»å¯¹æ”¶ç›Š
    bars['abs_ret'] = bars['log_return'].abs()

    # å‡†å¤‡å›å½’æ•°æ®
    valid_mask = bars[['R_past', 'sigma', 'abs_ret']].notna().all(axis=1)
    X = bars.loc[valid_mask, ['R_past', 'sigma']].values
    y = bars.loc[valid_mask, 'abs_ret'].values  # âœ… ä½¿ç”¨å½“å‰barçš„ç»å¯¹æ”¶ç›Š

    # æ‹Ÿåˆæ¨¡å‹
    model = LinearRegression()
    model.fit(X, y)
    
    # è®¡ç®—æ®‹å·®
    y_pred = model.predict(X)
    residuals = y - y_pred
    
    # æ ‡å‡†åŒ–
    manip_score = (residuals - residuals.mean()) / residuals.std()
    
    # å¡«å……
    bars.loc[valid_mask, 'ManipScore'] = manip_score
    bars['ManipScore'] = bars['ManipScore'].fillna(0)
    
    return bars, model

# ===== ä¿¡å·ç”Ÿæˆ =====
def generate_asymmetric_signals(bars, config):
    """ç”Ÿæˆéå¯¹ç§°ä¿¡å·"""
    bars = compute_trend_strength(bars, config.L_past, config.vol_window)
    
    # æç«¯é˜ˆå€¼
    threshold = bars['TS'].abs().quantile(config.q_extreme_trend)
    extreme_up = bars['TS'] > threshold
    extreme_down = bars['TS'] < -threshold
    
    # é«˜æ“çºµ
    manip_threshold = bars['ManipScore'].quantile(config.q_manip)
    high_manip = bars['ManipScore'] > manip_threshold
    
    # ç”Ÿæˆä¿¡å·
    signals = pd.DataFrame(index=bars.index)
    signals['signal'] = 0
    signals.loc[extreme_up & high_manip, 'signal'] = 1
    signals.loc[extreme_down & high_manip, 'signal'] = 1
    signals['signal'] = signals['signal'].shift(1).fillna(0)
    
    return signals

# ===== ATRè®¡ç®— =====
def compute_atr(bars, window=10):
    """è®¡ç®—ATR"""
    high_low = bars['high'] - bars['low']
    high_close = (bars['high'] - bars['close'].shift(1)).abs()
    low_close = (bars['low'] - bars['close'].shift(1)).abs()
    
    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    atr = tr.rolling(window=window).mean()
    
    return atr

# ===== å›æµ‹å¼•æ“ =====
def run_backtest(bars, signals, config, initial_capital=10000):
    """è¿è¡Œå›æµ‹"""
    equity = initial_capital
    position = None
    trades = []
    equity_curve = []
    
    # è®¡ç®—ATR
    atr = compute_atr(bars, config.atr_window)
    
    for t in range(len(bars)):
        # è®°å½•æƒç›Š
        equity_curve.append(equity)
        
        # æ£€æŸ¥å‡ºåœº
        if position is not None:
            current_price = bars['close'].iloc[t]
            bars_held = t - position.entry_bar
            
            exit_reason = None
            exit_price = None
            
            # æ­¢æŸ
            if current_price <= position.sl_price:
                exit_reason = 'SL'
                exit_price = position.sl_price
            # æ­¢ç›ˆ
            elif current_price >= position.tp_price:
                exit_reason = 'TP'
                exit_price = position.tp_price
            # æ—¶é—´æ­¢æŸ
            elif bars_held >= config.holding_horizon:
                exit_reason = 'TIME'
                exit_price = current_price
            
            # æ‰§è¡Œå‡ºåœº
            if exit_reason:
                pnl_pct = (exit_price - position.entry_price) / position.entry_price
                pnl_pct -= config.cost_per_trade
                
                position.exit_time = bars.index[t]
                position.exit_price = exit_price
                position.exit_reason = exit_reason
                position.pnl_pct = pnl_pct
                position.pnl = equity * pnl_pct
                
                equity += position.pnl
                trades.append(position)
                position = None
        
        # æ£€æŸ¥å…¥åœº
        if position is None and signals['signal'].iloc[t] == 1:
            entry_price = bars['close'].iloc[t]
            
            # è®¡ç®—æ­¢æŸæ­¢ç›ˆ
            sl_price = entry_price - config.sl_atr_mult * atr.iloc[t]
            tp_price = entry_price + config.tp_atr_mult * atr.iloc[t]
            
            position = Trade(
                entry_time=bars.index[t],
                entry_price=entry_price,
                direction=1,
                sl_price=sl_price,
                tp_price=tp_price
            )
            position.entry_bar = t
    
    # è®¡ç®—ç»Ÿè®¡
    equity_curve = pd.Series(equity_curve, index=bars.index)
    returns = equity_curve.pct_change().dropna()
    
    stats = {
        'total_return': (equity - initial_capital) / initial_capital,
        'sharpe_ratio': returns.mean() / returns.std() * np.sqrt(252) if returns.std() > 0 else 0,
        'max_drawdown': (equity_curve / equity_curve.cummax() - 1).min(),
        'num_trades': len(trades),
        'win_rate': sum(1 for t in trades if t.pnl > 0) / len(trades) if trades else 0
    }
    
    return {
        'trades': trades,
        'equity_curve': equity_curve,
        'stats': stats
    }

# ===== ä¸»æµç¨‹ =====
def main():
    # 1. åŠ è½½æ•°æ®
    bars = pd.read_csv('bars_60min.csv', index_col=0, parse_dates=True)
    
    # 2. æ‹ŸåˆManipScoreæ¨¡å‹
    bars, model = fit_manipscore_model(bars, L_past=5, L_future=5, vol_window=20)
    
    # 3. é…ç½®ç­–ç•¥
    config = ExtremeReversalConfig(
        bar_size="60min",
        L_past=5,
        vol_window=20,
        q_extreme_trend=0.9,
        q_manip=0.9,
        holding_horizon=5,
        atr_window=10,
        sl_atr_mult=999.0,
        tp_atr_mult=999.0,
        cost_per_trade=0.0007
    )
    
    # 4. ç”Ÿæˆä¿¡å·
    signals = generate_asymmetric_signals(bars, config)
    
    # 5. è¿è¡Œå›æµ‹
    result = run_backtest(bars, signals, config, initial_capital=10000)
    
    # 6. è¾“å‡ºç»“æœ
    print(f"Total Return: {result['stats']['total_return']*100:.2f}%")
    print(f"Sharpe Ratio: {result['stats']['sharpe_ratio']:.2f}")
    print(f"Max Drawdown: {result['stats']['max_drawdown']*100:.2f}%")
    print(f"Number of Trades: {result['stats']['num_trades']}")
    print(f"Win Rate: {result['stats']['win_rate']*100:.1f}%")

if __name__ == "__main__":
    main()
```

---

## éªŒè¯æ–¹æ³•

### 1. æ•°æ®éªŒè¯

**æ£€æŸ¥ç‚¹**:
```python
# æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
assert bars['close'].notna().all(), "å­˜åœ¨ç¼ºå¤±å€¼"
assert (bars['close'] > 0).all(), "å­˜åœ¨éæ­£ä»·æ ¼"
assert bars.index.is_monotonic_increasing, "æ—¶é—´åºåˆ—ä¸å•è°ƒ"

# æ£€æŸ¥æ•°æ®èŒƒå›´
print(f"æ•°æ®èµ·å§‹: {bars.index[0]}")
print(f"æ•°æ®ç»“æŸ: {bars.index[-1]}")
print(f"æ€»baræ•°: {len(bars)}")
```

---

### 2. ç‰¹å¾éªŒè¯

**æ£€æŸ¥ManipScoreåˆ†å¸ƒ**:
```python
print(f"ManipScoreå‡å€¼: {bars['ManipScore'].mean():.4f}")  # åº”æ¥è¿‘0
print(f"ManipScoreæ ‡å‡†å·®: {bars['ManipScore'].std():.4f}")  # åº”æ¥è¿‘1
print(f"ManipScoreèŒƒå›´: [{bars['ManipScore'].min():.2f}, {bars['ManipScore'].max():.2f}]")
```

**æ£€æŸ¥TSåˆ†å¸ƒ**:
```python
print(f"TSå‡å€¼: {bars['TS'].mean():.4f}")
print(f"TSæ ‡å‡†å·®: {bars['TS'].std():.4f}")
print(f"æç«¯é˜ˆå€¼: {bars['TS'].abs().quantile(0.9):.4f}")
```

---

### 3. ä¿¡å·éªŒè¯

**æ£€æŸ¥ä¿¡å·é¢‘ç‡**:
```python
signal_count = signals['signal'].sum()
signal_rate = signal_count / len(signals)
print(f"ä¿¡å·æ•°é‡: {signal_count}")
print(f"ä¿¡å·é¢‘ç‡: {signal_rate*100:.2f}%")  # åº”åœ¨1-5%ä¹‹é—´
```

---

### 4. å›æµ‹éªŒè¯

**æ£€æŸ¥å…³é”®æŒ‡æ ‡**:
```python
# BTC 60minçº¯å› å­çš„é¢„æœŸç»“æœï¼ˆ7bpæˆæœ¬ï¼‰
expected = {
    'total_return': 7.9884,  # 798.84%
    'sharpe_ratio': 16.50,
    'max_drawdown': -0.3117,  # -31.17%
    'num_trades': 1117,
    'win_rate': 0.526  # 52.6%
}

# éªŒè¯
tolerance = 0.05  # 5%å®¹å·®
for key, expected_value in expected.items():
    actual_value = result['stats'][key]
    diff = abs(actual_value - expected_value) / abs(expected_value)
    assert diff < tolerance, f"{key}åå·®è¿‡å¤§: {actual_value} vs {expected_value}"
    print(f"âœ“ {key}: {actual_value:.4f} (é¢„æœŸ: {expected_value:.4f})")
```

---

## å¸¸è§é—®é¢˜

### Q1: ä¸ºä»€ä¹ˆManipScoreè¦æ ‡å‡†åŒ–ï¼Ÿ

**ç­”**: æ ‡å‡†åŒ–åçš„ManipScore:
- å‡å€¼ä¸º0ï¼Œæ ‡å‡†å·®ä¸º1
- ä¾¿äºè·¨æ—¶é—´æ®µæ¯”è¾ƒ
- ä¾¿äºè®¾ç½®ç»Ÿä¸€çš„é˜ˆå€¼ï¼ˆå¦‚90%åˆ†ä½æ•°ï¼‰

---

### Q2: ä¸ºä»€ä¹ˆä¿¡å·è¦å»¶è¿Ÿä¸€ä¸ªbarï¼Ÿ

**ç­”**: é¿å…å‰è§†åå·®ï¼ˆLook-ahead Biasï¼‰
- åœ¨bar[t]ç»“æŸæ—¶æ‰èƒ½è®¡ç®—ç‰¹å¾
- åªèƒ½åœ¨bar[t+1]å¼€ç›˜æ—¶æ‰§è¡Œäº¤æ˜“
- å»¶è¿Ÿç¡®ä¿ä½¿ç”¨çš„æ˜¯å·²çŸ¥ä¿¡æ¯

---

### Q3: ä¸ºä»€ä¹ˆ60åˆ†é’Ÿè¡¨ç°æœ€å¥½ï¼Ÿ

**ç­”**: 
- 5åˆ†é’Ÿï¼šäº¤æ˜“æˆæœ¬å æ¯”è¿‡é«˜
- 15åˆ†é’Ÿï¼šä»ç„¶é¢‘ç¹ï¼Œæˆæœ¬å½±å“å¤§
- **60åˆ†é’Ÿ**ï¼šå¹³è¡¡äº†ä¿¡å·è´¨é‡å’Œäº¤æ˜“æˆæœ¬
- 4å°æ—¶ï¼šä¿¡å·è¾ƒå°‘ï¼Œä½†è´¨é‡æé«˜

---

### Q4: æ­¢æŸæ­¢ç›ˆåº”è¯¥ç”¨å—ï¼Ÿ

**ç­”**: å–å†³äºæ—¶é—´å‘¨æœŸ
- 60åˆ†é’Ÿï¼š**ä¸ç”¨**ï¼ˆçº¯å› å­æ›´å¥½ï¼‰
- 30åˆ†é’Ÿï¼š**ç”¨**ï¼ˆæå‡è¡¨ç°ï¼‰
- 4å°æ—¶ï¼š**å¯é€‰**ï¼ˆå½±å“ä¸å¤§ï¼‰

---

### Q5: å¦‚ä½•å¤„ç†æ•°æ®ç¼ºå¤±ï¼Ÿ

**ç­”**:
```python
# æ–¹æ³•1: å‰å‘å¡«å……
bars = bars.ffill()

# æ–¹æ³•2: åˆ é™¤ç¼ºå¤±
bars = bars.dropna()

# æ–¹æ³•3: æ’å€¼
bars = bars.interpolate(method='linear')
```

æ¨èï¼šå‰å‘å¡«å…… + åˆ é™¤å¼€å¤´ç¼ºå¤±

---

## é™„å½•

### A. æ•°å­¦ç¬¦å·è¡¨

| ç¬¦å· | å«ä¹‰ |
|------|------|
| `t` | å½“å‰æ—¶åˆ»ï¼ˆbarç´¢å¼•ï¼‰ |
| `P[t]` | æ—¶åˆ»tçš„ä»·æ ¼ |
| `R[t]` | æ—¶åˆ»tçš„å¯¹æ•°æ”¶ç›Šç‡ |
| `Ïƒ[t]` | æ—¶åˆ»tçš„æ³¢åŠ¨ç‡ |
| `TS[t]` | æ—¶åˆ»tçš„è¶‹åŠ¿å¼ºåº¦ |
| `MS[t]` | æ—¶åˆ»tçš„æ“çºµåˆ†æ•° |
| `L_past` | å›çœ‹çª—å£é•¿åº¦ |
| `L_future` | å‰ç»çª—å£é•¿åº¦ |
| `Î±, Î²` | å›å½’ç³»æ•° |
| `Îµ[t]` | æ®‹å·® |

---

### B. æ—¶é—´å‘¨æœŸè½¬æ¢

| å‘¨æœŸ | æ¯å¤©baræ•° | æ¯å¹´baræ•° | è¯´æ˜ |
|------|----------|----------|------|
| 5min | 288 | 105,120 | é«˜é¢‘ |
| 15min | 96 | 35,040 | ä¸­é«˜é¢‘ |
| 30min | 48 | 17,520 | ä¸­é¢‘ |
| 60min | 24 | 8,760 | **æ¨è** |
| 4h | 6 | 2,190 | ä½é¢‘ |
| 1d | 1 | 365 | æ—¥çº¿ |

---

### C. æ€§èƒ½åŸºå‡†ï¼ˆ7bpæˆæœ¬ï¼‰

| ç­–ç•¥ | å¹´åŒ–æ”¶ç›Š | Sharpe | æœ€å¤§å›æ’¤ | äº¤æ˜“/å¹´ |
|------|---------|--------|---------|---------|
| ETH 60min Pure | 35.01% | 14.18 | -53.76% | 145.1 |
| BTC 60min Pure | 33.25% | 16.50 | -31.17% | 146.0 |
| ETH 30min+SL/TP | 27.50% | 5.20 | -35.69% | 371.8 |
| BTC 4h Pure | 14.87% | 107.91 | -35.24% | 31.8 |

---

---

## è¯¦ç»†è®¡ç®—ç¤ºä¾‹

### å®Œæ•´ç¤ºä¾‹ï¼šä»åŸå§‹æ•°æ®åˆ°äº¤æ˜“ä¿¡å·

å‡è®¾æˆ‘ä»¬æœ‰ä»¥ä¸‹5åˆ†é’Ÿbaræ•°æ®ï¼ˆBTCï¼‰:

```
æ—¶é—´                  close
2024-01-01 00:00:00  42000.00
2024-01-01 00:05:00  42050.00
2024-01-01 00:10:00  42100.00
2024-01-01 00:15:00  42080.00
2024-01-01 00:20:00  42120.00
...ï¼ˆå…±100ä¸ªbarï¼‰
2024-01-01 08:15:00  42500.00
2024-01-01 08:20:00  42550.00  â† å½“å‰æ—¶åˆ»t
```

#### æ­¥éª¤1: è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡

```python
# t-1æ—¶åˆ»
close[t-1] = 42500.00
close[t] = 42550.00

log_return[t] = ln(42550.00 / 42500.00)
              = ln(1.001176)
              = 0.001175
              = 0.1175%
```

#### æ­¥éª¤2: è®¡ç®—æ³¢åŠ¨ç‡ï¼ˆå‡è®¾vol_window=20ï¼‰

```python
# è¿‡å»20ä¸ªbarçš„log_return
log_returns = [0.0012, -0.0008, 0.0015, ..., 0.0011, 0.0012]

sigma[t] = std(log_returns)
         = 0.0025
         = 0.25%
```

#### æ­¥éª¤3: è®¡ç®—è¶‹åŠ¿å¼ºåº¦ï¼ˆå‡è®¾L_past=5ï¼‰

```python
# è¿‡å»5ä¸ªbarçš„log_return
log_returns_5 = [0.0011, 0.0012, -0.0005, 0.0008, 0.0012]

R_past[t] = sum(log_returns_5)
          = 0.0011 + 0.0012 - 0.0005 + 0.0008 + 0.0012
          = 0.0038
          = 0.38%

TS[t] = R_past[t] / sigma[t]
      = 0.0038 / 0.0025
      = 1.52
```

#### æ­¥éª¤4: è®¡ç®—ManipScore

**4.1 è®¡ç®—æœªæ¥æ”¶ç›Šï¼ˆå‡è®¾L_future=5ï¼‰**

```python
# å½“å‰barçš„log_return
current_return = 0.0055

abs_ret[t] = |current_return|
           = |0.0055|
           = 0.0055
           = 0.55%
```

**4.2 å›å½’é¢„æµ‹**

å‡è®¾å·²ç»æ‹Ÿåˆçš„å›å½’æ¨¡å‹:
```
abs_ret = Î± + Î²â‚ * R_past + Î²â‚‚ * sigma
Î± = 0.0001
Î²â‚ = 0.3
Î²â‚‚ = 0.5
```

```python
abs_ret_pred[t] = 0.0001 + 0.3 * 0.0038 + 0.5 * 0.0025
                = 0.0001 + 0.00114 + 0.00125
                = 0.00249
                = 0.249%
```

**4.3 è®¡ç®—æ®‹å·®**

```python
residual[t] = abs_ret[t] - abs_ret_pred[t]
            = 0.0055 - 0.00249
            = 0.00301
            = 0.301%
```

**4.4 æ ‡å‡†åŒ–æ®‹å·®**

å‡è®¾æ‰€æœ‰æ®‹å·®çš„ç»Ÿè®¡:
```
mean(residuals) = 0.0000
std(residuals) = 0.0015
```

```python
ManipScore[t] = (residual[t] - mean) / std
              = (0.00301 - 0.0000) / 0.0015
              = 2.007
```

#### æ­¥éª¤5: åˆ¤æ–­æç«¯è¶‹åŠ¿

å‡è®¾90%åˆ†ä½æ•°é˜ˆå€¼:
```
threshold = 1.8
```

```python
TS[t] = 1.52
|TS[t]| = 1.52 < 1.8

æç«¯ä¸Šæ¶¨: False
æç«¯ä¸‹è·Œ: False
```

**æ­¤æ—¶åˆ»ä¸æ»¡è¶³æç«¯è¶‹åŠ¿æ¡ä»¶ï¼Œä¸äº§ç”Ÿä¿¡å·**

---

### ç¤ºä¾‹2ï¼šäº§ç”Ÿä¿¡å·çš„æƒ…å†µ

å‡è®¾å¦ä¸€ä¸ªæ—¶åˆ»t':

```python
# è®¡ç®—ç»“æœ
TS[t'] = 2.5
ManipScore[t'] = 2.3

# é˜ˆå€¼
threshold_TS = 1.8
threshold_Manip = 2.0  # 90%åˆ†ä½æ•°

# åˆ¤æ–­
æç«¯ä¸Šæ¶¨: TS[t'] = 2.5 > 1.8 â†’ True
é«˜æ“çºµ: ManipScore[t'] = 2.3 > 2.0 â†’ True

# ç”Ÿæˆä¿¡å·
signal[t'+1] = 1  # åœ¨ä¸‹ä¸€ä¸ªbaråšå¤š
```

#### æ‰§è¡Œäº¤æ˜“

```python
# åœ¨t'+1æ—¶åˆ»å¼€ç›˜
entry_time = t'+1
entry_price = close[t'+1] = 42600.00

# è®¡ç®—ATRï¼ˆå‡è®¾ATR=50.00ï¼‰
atr[t'+1] = 50.00

# è®¡ç®—æ­¢æŸæ­¢ç›ˆï¼ˆå‡è®¾sl_mult=0.5, tp_mult=0.8ï¼‰
sl_price = 42600.00 - 0.5 * 50.00 = 42575.00
tp_price = 42600.00 + 0.8 * 50.00 = 42640.00

# è®°å½•äº¤æ˜“
trade = {
    'entry_time': t'+1,
    'entry_price': 42600.00,
    'sl_price': 42575.00,
    'tp_price': 42640.00,
    'direction': 1  # åšå¤š
}
```

#### å‡ºåœºåœºæ™¯

**åœºæ™¯A: æ­¢ç›ˆè§¦å‘**

```python
# åœ¨t'+3æ—¶åˆ»
current_price = 42650.00

# æ£€æŸ¥
current_price >= tp_price â†’ 42650.00 >= 42640.00 â†’ True

# å‡ºåœº
exit_price = 42640.00  # æŒ‰æ­¢ç›ˆä»·å‡ºåœº
exit_reason = 'TP'

# è®¡ç®—æ”¶ç›Š
pnl_pct = (42640.00 - 42600.00) / 42600.00
        = 40.00 / 42600.00
        = 0.000939
        = 0.0939%

# æ‰£é™¤æˆæœ¬
pnl_pct_net = 0.000939 - 0.0007  # 7bpæˆæœ¬
            = 0.000239
            = 0.0239%

# æ›´æ–°æƒç›Šï¼ˆå‡è®¾åˆå§‹10000ï¼‰
pnl = 10000 * 0.000239 = 2.39
equity = 10000 + 2.39 = 10002.39
```

**åœºæ™¯B: æ­¢æŸè§¦å‘**

```python
# åœ¨t'+2æ—¶åˆ»
current_price = 42570.00

# æ£€æŸ¥
current_price <= sl_price â†’ 42570.00 <= 42575.00 â†’ True

# å‡ºåœº
exit_price = 42575.00  # æŒ‰æ­¢æŸä»·å‡ºåœº
exit_reason = 'SL'

# è®¡ç®—æ”¶ç›Š
pnl_pct = (42575.00 - 42600.00) / 42600.00
        = -25.00 / 42600.00
        = -0.000587
        = -0.0587%

# æ‰£é™¤æˆæœ¬
pnl_pct_net = -0.000587 - 0.0007
            = -0.001287
            = -0.1287%

# æ›´æ–°æƒç›Š
pnl = 10000 * (-0.001287) = -12.87
equity = 10000 - 12.87 = 9987.13
```

**åœºæ™¯C: æ—¶é—´æ­¢æŸ**

```python
# åœ¨t'+6æ—¶åˆ»ï¼ˆæŒä»“5ä¸ªbaråï¼‰
bars_held = 6 - 1 = 5
holding_horizon = 5

# æ£€æŸ¥
bars_held >= holding_horizon â†’ 5 >= 5 â†’ True

# å‡ºåœº
current_price = 42620.00
exit_price = 42620.00  # æŒ‰å½“å‰ä»·å‡ºåœº
exit_reason = 'TIME'

# è®¡ç®—æ”¶ç›Š
pnl_pct = (42620.00 - 42600.00) / 42600.00
        = 20.00 / 42600.00
        = 0.000469
        = 0.0469%

# æ‰£é™¤æˆæœ¬
pnl_pct_net = 0.000469 - 0.0007
            = -0.000231
            = -0.0231%

# æ›´æ–°æƒç›Š
pnl = 10000 * (-0.000231) = -2.31
equity = 10000 - 2.31 = 9997.69
```

---

## å®ç°æ£€æŸ¥æ¸…å•

### æ•°æ®å‡†å¤‡ âœ“

- [ ] ä¸‹è½½tickæˆ–baræ•°æ®
- [ ] æ£€æŸ¥æ•°æ®å®Œæ•´æ€§ï¼ˆæ— ç¼ºå¤±ï¼‰
- [ ] æ£€æŸ¥æ•°æ®æ ¼å¼ï¼ˆæ—¶é—´æˆ³ã€ä»·æ ¼åˆ—ï¼‰
- [ ] è½¬æ¢ä¸ºç»Ÿä¸€æ—¶åŒºï¼ˆUTCï¼‰
- [ ] å¦‚æœæ˜¯tickæ•°æ®ï¼Œèšåˆä¸º5åˆ†é’Ÿbar
- [ ] ä¿å­˜ä¸ºCSVæˆ–Parquetæ ¼å¼

### ç‰¹å¾å·¥ç¨‹ âœ“

- [ ] è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡
- [ ] è®¡ç®—æ»šåŠ¨æ³¢åŠ¨ç‡ï¼ˆ20ä¸ªbarï¼‰
- [ ] è®¡ç®—ç´¯è®¡æ”¶ç›Šï¼ˆ5ä¸ªbarï¼‰
- [ ] è®¡ç®—è¶‹åŠ¿å¼ºåº¦ï¼ˆTSï¼‰
- [ ] æ‹Ÿåˆå›å½’æ¨¡å‹ï¼ˆabs_ret ~ R_past + sigmaï¼‰
- [ ] è®¡ç®—æ®‹å·®
- [ ] æ ‡å‡†åŒ–æ®‹å·®å¾—åˆ°ManipScore
- [ ] éªŒè¯ManipScoreå‡å€¼â‰ˆ0ï¼Œæ ‡å‡†å·®â‰ˆ1

### ä¿¡å·ç”Ÿæˆ âœ“

- [ ] è®¡ç®—æç«¯è¶‹åŠ¿é˜ˆå€¼ï¼ˆ90%åˆ†ä½æ•°ï¼‰
- [ ] è¯†åˆ«æç«¯ä¸Šæ¶¨ï¼ˆTS > thresholdï¼‰
- [ ] è¯†åˆ«æç«¯ä¸‹è·Œï¼ˆTS < -thresholdï¼‰
- [ ] è®¡ç®—é«˜æ“çºµé˜ˆå€¼ï¼ˆ90%åˆ†ä½æ•°ï¼‰
- [ ] è¯†åˆ«é«˜æ“çºµï¼ˆManipScore > thresholdï¼‰
- [ ] ç”Ÿæˆä¿¡å·ï¼ˆæç«¯ AND é«˜æ“çºµï¼‰
- [ ] å»¶è¿Ÿä¿¡å·1ä¸ªbar
- [ ] éªŒè¯ä¿¡å·é¢‘ç‡ï¼ˆ1-5%ï¼‰

### å›æµ‹æ‰§è¡Œ âœ“

- [ ] è®¡ç®—ATRï¼ˆ10ä¸ªbarï¼‰
- [ ] åˆå§‹åŒ–æƒç›Šï¼ˆ10000ï¼‰
- [ ] éå†æ¯ä¸ªbar
- [ ] æ£€æŸ¥å‡ºåœºæ¡ä»¶ï¼ˆæ­¢æŸ/æ­¢ç›ˆ/æ—¶é—´ï¼‰
- [ ] æ£€æŸ¥å…¥åœºæ¡ä»¶ï¼ˆä¿¡å·=1ä¸”æ— æŒä»“ï¼‰
- [ ] è®°å½•æ¯ç¬”äº¤æ˜“
- [ ] è®¡ç®—æƒç›Šæ›²çº¿
- [ ] æ‰£é™¤äº¤æ˜“æˆæœ¬ï¼ˆ7bpï¼‰

### ç»“æœéªŒè¯ âœ“

- [ ] è®¡ç®—æ€»æ”¶ç›Š
- [ ] è®¡ç®—å¹´åŒ–æ”¶ç›Š
- [ ] è®¡ç®—Sharpeæ¯”ç‡
- [ ] è®¡ç®—æœ€å¤§å›æ’¤
- [ ] è®¡ç®—èƒœç‡
- [ ] è®¡ç®—äº¤æ˜“æ¬¡æ•°
- [ ] ä¸åŸºå‡†ç»“æœå¯¹æ¯”ï¼ˆå®¹å·®5%ï¼‰

---

## å¸¸è§é”™è¯¯åŠè§£å†³

### é”™è¯¯1: ManipScoreå…¨æ˜¯NaN

**åŸå› **: å›å½’æ•°æ®ä¸è¶³

**è§£å†³**:
```python
# ç¡®ä¿æœ‰è¶³å¤Ÿçš„æ•°æ®
min_bars = max(L_past, vol_window) + 10
assert len(bars) >= min_bars, f"éœ€è¦è‡³å°‘{min_bars}ä¸ªbar"

# æ£€æŸ¥ç¼ºå¤±å€¼
assert bars[['R_past', 'sigma', 'abs_ret']].notna().sum() > 100
```

---

### é”™è¯¯2: ä¿¡å·é¢‘ç‡è¿‡é«˜ï¼ˆ>10%ï¼‰

**åŸå› **: é˜ˆå€¼è®¾ç½®è¿‡ä½

**è§£å†³**:
```python
# æé«˜åˆ†ä½æ•°
q_extreme_trend = 0.95  # ä»0.9æé«˜åˆ°0.95
q_manip = 0.95

# æˆ–è€…ä½¿ç”¨ç»å¯¹é˜ˆå€¼
threshold_TS = 2.0  # å›ºå®šé˜ˆå€¼
threshold_Manip = 2.0
```

---

### é”™è¯¯3: å›æµ‹æ”¶ç›Šä¸é¢„æœŸå·®å¼‚å¤§

**åŸå› **:
1. æ•°æ®ä¸åŒ
2. å‚æ•°ä¸åŒ
3. æˆæœ¬è®¾ç½®ä¸åŒ
4. å®ç°æœ‰è¯¯

**è§£å†³**:
```python
# 1. éªŒè¯æ•°æ®
print(f"æ•°æ®èµ·å§‹: {bars.index[0]}")
print(f"æ•°æ®ç»“æŸ: {bars.index[-1]}")
print(f"Baræ•°é‡: {len(bars)}")

# 2. éªŒè¯å‚æ•°
print(f"L_past: {config.L_past}")
print(f"vol_window: {config.vol_window}")
print(f"cost: {config.cost_per_trade}")

# 3. éªŒè¯ä¸­é—´ç»“æœ
print(f"TSå‡å€¼: {bars['TS'].mean():.4f}")
print(f"ManipScoreå‡å€¼: {bars['ManipScore'].mean():.4f}")
print(f"ä¿¡å·æ•°é‡: {signals['signal'].sum()}")

# 4. é€æ­¥è°ƒè¯•
# æ‰“å°å‰10ç¬”äº¤æ˜“
for i, trade in enumerate(trades[:10]):
    print(f"Trade {i}: {trade}")
```

---

### é”™è¯¯4: æ­¢æŸæ­¢ç›ˆä»·æ ¼å¼‚å¸¸

**åŸå› **: ATRè®¡ç®—é”™è¯¯æˆ–ä¸ºNaN

**è§£å†³**:
```python
# æ£€æŸ¥ATR
atr = compute_atr(bars, window=10)
print(f"ATRå‡å€¼: {atr.mean():.2f}")
print(f"ATRèŒƒå›´: [{atr.min():.2f}, {atr.max():.2f}]")
print(f"ATRç¼ºå¤±: {atr.isna().sum()}")

# å¡«å……ATRç¼ºå¤±å€¼
atr = atr.ffill().bfill()

# è®¾ç½®æœ€å°ATR
atr = atr.clip(lower=bars['close'].mean() * 0.001)  # è‡³å°‘0.1%
```

---

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. å‘é‡åŒ–è®¡ç®—

**æ…¢é€Ÿç‰ˆæœ¬**ï¼ˆå¾ªç¯ï¼‰:
```python
for i in range(len(bars)):
    bars.loc[i, 'log_return'] = np.log(bars.loc[i, 'close'] / bars.loc[i-1, 'close'])
```

**å¿«é€Ÿç‰ˆæœ¬**ï¼ˆå‘é‡åŒ–ï¼‰:
```python
bars['log_return'] = np.log(bars['close'] / bars['close'].shift(1))
```

é€Ÿåº¦æå‡: **100å€ä»¥ä¸Š**

---

### 2. ä½¿ç”¨NumbaåŠ é€Ÿ

```python
from numba import jit

@jit(nopython=True)
def compute_ts_fast(log_returns, sigma, L_past):
    """ä½¿ç”¨NumbaåŠ é€Ÿçš„TSè®¡ç®—"""
    n = len(log_returns)
    ts = np.zeros(n)

    for i in range(L_past, n):
        r_past = np.sum(log_returns[i-L_past:i])
        ts[i] = r_past / sigma[i]

    return ts
```

é€Ÿåº¦æå‡: **10-50å€**

---

### 3. å¹¶è¡Œå¤„ç†

```python
from joblib import Parallel, delayed

def process_year(year_data):
    """å¤„ç†å•å¹´æ•°æ®"""
    bars, model = fit_manipscore_model(year_data)
    return bars

# å¹¶è¡Œå¤„ç†å¤šå¹´æ•°æ®
results = Parallel(n_jobs=-1)(
    delayed(process_year)(year_data)
    for year_data in yearly_data
)
```

é€Ÿåº¦æå‡: **æ¥è¿‘CPUæ ¸å¿ƒæ•°**

---

## å®ç›˜å®ç°æŒ‡å—

### ğŸš€ å¿«é€Ÿå¼€å§‹ï¼ˆä»…ä½¿ç”¨Kçº¿æ•°æ®ï¼‰

#### æ­¥éª¤1: è·å–å†å²Kçº¿æ•°æ®

```python
import ccxt
import pandas as pd

# åˆå§‹åŒ–äº¤æ˜“æ‰€
exchange = ccxt.binance()

# è·å–å†å²Kçº¿æ•°æ®ï¼ˆç”¨äºè®­ç»ƒManipScoreæ¨¡å‹ï¼‰
# å»ºè®®è‡³å°‘5000ä¸ªbar
ohlcv = exchange.fetch_ohlcv('BTC/USDT', '1h', limit=5000)

# è½¬æ¢ä¸ºDataFrame
bars = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
bars['timestamp'] = pd.to_datetime(bars['timestamp'], unit='ms')
bars.set_index('timestamp', inplace=True)

print(f"è·å–äº† {len(bars)} ä¸ªKçº¿")
print(f"æ—¶é—´èŒƒå›´: {bars.index[0]} åˆ° {bars.index[-1]}")
```

---

#### æ­¥éª¤2: è®­ç»ƒManipScoreæ¨¡å‹

```python
from src.features.manipscore_model import fit_manipscore_model, apply_manipscore

# è®¡ç®—æ”¶ç›Šç‡
bars['returns'] = bars['close'].pct_change()

# è®­ç»ƒManipScoreæ¨¡å‹
# æ³¨æ„: å¦‚æœåªæœ‰OHLCæ•°æ®ï¼Œæ¨¡å‹ä¼šè‡ªåŠ¨ä½¿ç”¨æ»åæ”¶ç›Šä½œä¸ºç‰¹å¾
model = fit_manipscore_model(bars, bar_size='60min')

print(f"æ¨¡å‹ç‰¹å¾: {model.feature_cols}")
print(f"æ®‹å·®æ ‡å‡†å·®: {model.residual_std:.6f}")

# ä¿å­˜æ¨¡å‹ï¼ˆé¿å…æ¯æ¬¡éƒ½é‡æ–°è®­ç»ƒï¼‰
import pickle
with open('manipscore_model_60min.pkl', 'wb') as f:
    pickle.dump(model, f)
```

**æ¨¡å‹ç‰¹å¾è¯´æ˜**:
- å¦‚æœåªæœ‰OHLCæ•°æ®ï¼Œæ¨¡å‹ä¼šä½¿ç”¨: `['abs_ret_lag1', 'abs_ret_lag2']`
- å¦‚æœæœ‰volumeï¼Œä¼šé¢å¤–ä½¿ç”¨: `['volume']`
- å¦‚æœæœ‰tickæ•°æ®ï¼Œä¼šä½¿ç”¨: `['N_ticks', 'spread_mean', 'RV', 'abs_ret_lag1', 'abs_ret_lag2']`

---

#### æ­¥éª¤3: è®¡ç®—é˜ˆå€¼ï¼ˆä½¿ç”¨å†å²æ•°æ®ï¼‰

```python
from src.strategies.trend_features import compute_trend_strength
from src.strategies.extreme_reversal import ExtremeReversalConfig

# é…ç½®
config = ExtremeReversalConfig(
    bar_size='60min',
    L_past=5,
    vol_window=20,
    q_extreme_trend=0.9,
    q_manip=0.9,
    holding_horizon=5,
    atr_window=10,
    sl_atr_mult=0.5,
    tp_atr_mult=0.8,
    cost_per_trade=0.0007  # 7bp
)

# åº”ç”¨ManipScore
bars = apply_manipscore(bars, model)

# è®¡ç®—è¶‹åŠ¿å¼ºåº¦
bars = compute_trend_strength(bars, L_past=config.L_past, vol_window=config.vol_window)

# è®¡ç®—é˜ˆå€¼ï¼ˆä½¿ç”¨æœ€è¿‘500ä¸ªbarï¼‰
recent_bars = bars.tail(500)
threshold_TS = recent_bars['TS'].abs().quantile(config.q_extreme_trend)
threshold_MS = recent_bars['ManipScore'].quantile(config.q_manip)

print(f"TSé˜ˆå€¼: {threshold_TS:.4f}")
print(f"ManipScoreé˜ˆå€¼: {threshold_MS:.4f}")

# ä¿å­˜é˜ˆå€¼
thresholds = {
    'threshold_TS': threshold_TS,
    'threshold_MS': threshold_MS,
    'last_update': pd.Timestamp.now()
}
with open('thresholds_60min.pkl', 'wb') as f:
    pickle.dump(thresholds, f)
```

---

#### æ­¥éª¤4: å®æ—¶ä¿¡å·ç”Ÿæˆ

```python
import time

# åŠ è½½æ¨¡å‹å’Œé˜ˆå€¼
with open('manipscore_model_60min.pkl', 'rb') as f:
    model = pickle.load(f)

with open('thresholds_60min.pkl', 'rb') as f:
    thresholds = pickle.load(f)

threshold_TS = thresholds['threshold_TS']
threshold_MS = thresholds['threshold_MS']

def get_latest_signal():
    """è·å–æœ€æ–°çš„äº¤æ˜“ä¿¡å·"""
    # 1. è·å–æœ€æ–°Kçº¿æ•°æ®ï¼ˆéœ€è¦è¶³å¤Ÿçš„å†å²æ•°æ®æ¥è®¡ç®—ç‰¹å¾ï¼‰
    ohlcv = exchange.fetch_ohlcv('BTC/USDT', '1h', limit=100)
    bars = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    bars['timestamp'] = pd.to_datetime(bars['timestamp'], unit='ms')
    bars.set_index('timestamp', inplace=True)

    # 2. è®¡ç®—æ”¶ç›Šç‡
    bars['returns'] = bars['close'].pct_change()

    # 3. åº”ç”¨ManipScore
    bars = apply_manipscore(bars, model)

    # 4. è®¡ç®—è¶‹åŠ¿å¼ºåº¦
    bars = compute_trend_strength(bars, L_past=config.L_past, vol_window=config.vol_window)

    # 5. ç”Ÿæˆä¿¡å·ï¼ˆä½¿ç”¨æœ€æ–°çš„barï¼‰
    latest = bars.iloc[-1]

    extreme_up = latest['TS'] > threshold_TS
    extreme_down = latest['TS'] < -threshold_TS
    high_manip = latest['ManipScore'] > threshold_MS

    # éå¯¹ç§°ä¿¡å·ï¼šUPå’ŒDOWNéƒ½åšå¤š
    signal = 1 if (extreme_up or extreme_down) and high_manip else 0

    return {
        'timestamp': bars.index[-1],
        'signal': signal,
        'TS': latest['TS'],
        'ManipScore': latest['ManipScore'],
        'close': latest['close'],
        'extreme_up': extreme_up,
        'extreme_down': extreme_down,
        'high_manip': high_manip
    }

# ä¸»å¾ªç¯ï¼ˆæ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡ï¼‰
while True:
    try:
        signal_info = get_latest_signal()

        print(f"\næ—¶é—´: {signal_info['timestamp']}")
        print(f"ä»·æ ¼: {signal_info['close']:.2f}")
        print(f"TS: {signal_info['TS']:.4f}")
        print(f"ManipScore: {signal_info['ManipScore']:.4f}")
        print(f"ä¿¡å·: {signal_info['signal']}")

        if signal_info['signal'] == 1:
            print("ğŸš€ å¼€ä»“ä¿¡å·ï¼")
            # æ‰§è¡Œäº¤æ˜“é€»è¾‘
            # place_order(...)

        # ç­‰å¾…ä¸‹ä¸€ä¸ªå°æ—¶
        time.sleep(3600)

    except Exception as e:
        print(f"é”™è¯¯: {e}")
        time.sleep(60)
```

---

#### æ­¥éª¤5: å®šæœŸæ›´æ–°æ¨¡å‹å’Œé˜ˆå€¼

```python
# å»ºè®®æ¯å‘¨æˆ–æ¯æœˆæ›´æ–°ä¸€æ¬¡
def update_model_and_thresholds():
    """æ›´æ–°ManipScoreæ¨¡å‹å’Œé˜ˆå€¼"""
    # 1. è·å–æœ€æ–°çš„å†å²æ•°æ®
    ohlcv = exchange.fetch_ohlcv('BTC/USDT', '1h', limit=5000)
    bars = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    bars['timestamp'] = pd.to_datetime(bars['timestamp'], unit='ms')
    bars.set_index('timestamp', inplace=True)
    bars['returns'] = bars['close'].pct_change()

    # 2. é‡æ–°è®­ç»ƒæ¨¡å‹
    model = fit_manipscore_model(bars, bar_size='60min')

    # 3. é‡æ–°è®¡ç®—é˜ˆå€¼
    bars = apply_manipscore(bars, model)
    bars = compute_trend_strength(bars, L_past=config.L_past, vol_window=config.vol_window)

    recent_bars = bars.tail(500)
    threshold_TS = recent_bars['TS'].abs().quantile(config.q_extreme_trend)
    threshold_MS = recent_bars['ManipScore'].quantile(config.q_manip)

    # 4. ä¿å­˜
    with open('manipscore_model_60min.pkl', 'wb') as f:
        pickle.dump(model, f)

    thresholds = {
        'threshold_TS': threshold_TS,
        'threshold_MS': threshold_MS,
        'last_update': pd.Timestamp.now()
    }
    with open('thresholds_60min.pkl', 'wb') as f:
        pickle.dump(thresholds, f)

    print(f"æ¨¡å‹å’Œé˜ˆå€¼å·²æ›´æ–°: {pd.Timestamp.now()}")

# æ¯å‘¨æ—¥å‡Œæ™¨æ›´æ–°
import schedule
schedule.every().sunday.at("00:00").do(update_model_and_thresholds)
```

---

### ğŸ“‹ å®ç›˜æ£€æŸ¥æ¸…å•

åœ¨å¼€å§‹å®ç›˜äº¤æ˜“å‰ï¼Œè¯·ç¡®è®¤ï¼š

- [ ] **æ•°æ®è·å–**: èƒ½å¤Ÿç¨³å®šè·å–Kçº¿æ•°æ®
- [ ] **æ¨¡å‹è®­ç»ƒ**: ä½¿ç”¨è‡³å°‘1000ä¸ªbarè®­ç»ƒManipScoreæ¨¡å‹
- [ ] **é˜ˆå€¼è®¡ç®—**: ä½¿ç”¨æœ€è¿‘500ä¸ªbarè®¡ç®—é˜ˆå€¼
- [ ] **ä¿¡å·éªŒè¯**: åœ¨å†å²æ•°æ®ä¸ŠéªŒè¯ä¿¡å·ç”Ÿæˆé€»è¾‘
- [ ] **é£é™©ç®¡ç†**: è®¾ç½®æ­¢æŸæ­¢ç›ˆï¼ˆATRå€æ•°ï¼‰
- [ ] **äº¤æ˜“æˆæœ¬**: ç¡®è®¤å®é™…äº¤æ˜“æˆæœ¬ï¼ˆå»ºè®®7bpï¼‰
- [ ] **ä»“ä½ç®¡ç†**: è®¾ç½®å•ç¬”äº¤æ˜“çš„èµ„é‡‘æ¯”ä¾‹
- [ ] **å¼‚å¸¸å¤„ç†**: å¤„ç†APIé”™è¯¯ã€ç½‘ç»œä¸­æ–­ç­‰
- [ ] **æ—¥å¿—è®°å½•**: è®°å½•æ‰€æœ‰äº¤æ˜“å’Œä¿¡å·
- [ ] **å®šæœŸæ›´æ–°**: è®¾ç½®æ¨¡å‹å’Œé˜ˆå€¼çš„æ›´æ–°é¢‘ç‡

---

### âš ï¸ å®ç›˜æ³¨æ„äº‹é¡¹

#### 1. æ•°æ®è´¨é‡

```python
# æ£€æŸ¥Kçº¿æ•°æ®è´¨é‡
def validate_bars(bars):
    """éªŒè¯Kçº¿æ•°æ®è´¨é‡"""
    # æ£€æŸ¥ç¼ºå¤±å€¼
    if bars.isnull().any().any():
        print("è­¦å‘Š: æ•°æ®åŒ…å«ç¼ºå¤±å€¼")
        return False

    # æ£€æŸ¥ä»·æ ¼åˆç†æ€§
    if (bars['high'] < bars['low']).any():
        print("è­¦å‘Š: high < low")
        return False

    if (bars['high'] < bars['close']).any() or (bars['low'] > bars['close']).any():
        print("è­¦å‘Š: closeè¶…å‡ºhigh/lowèŒƒå›´")
        return False

    # æ£€æŸ¥æ—¶é—´è¿ç»­æ€§
    time_diff = bars.index.to_series().diff()
    expected_diff = pd.Timedelta('1h')  # å¯¹äº1å°æ—¶Kçº¿
    if (time_diff[1:] != expected_diff).any():
        print("è­¦å‘Š: æ—¶é—´ä¸è¿ç»­")
        return False

    return True
```

#### 2. æ»‘ç‚¹å’Œæˆæœ¬

```python
# å®ç›˜äº¤æ˜“æˆæœ¬é€šå¸¸é«˜äºå›æµ‹
config.cost_per_trade = 0.0007  # 7bp (0.07%)

# è€ƒè™‘æ»‘ç‚¹
slippage = 0.0002  # 2bp
total_cost = config.cost_per_trade + slippage  # 9bp
```

#### 3. ä»“ä½ç®¡ç†

```python
# å»ºè®®ä½¿ç”¨å›ºå®šæ¯”ä¾‹ä»“ä½
position_size_pct = 0.1  # æ¯æ¬¡ä½¿ç”¨10%çš„èµ„é‡‘

# è®¡ç®—äº¤æ˜“æ•°é‡
capital = 10000  # æ€»èµ„é‡‘
price = bars['close'].iloc[-1]
position_value = capital * position_size_pct
quantity = position_value / price

print(f"äº¤æ˜“æ•°é‡: {quantity:.6f}")
```

---

## æ‰©å±•æ–¹å‘

### 1. å¤šèµ„äº§ç»„åˆ

```python
# åŒæ—¶äº¤æ˜“BTCå’ŒETH
assets = ['BTC', 'ETH']
weights = [0.5, 0.5]  # ç­‰æƒé‡

# åˆ†åˆ«ç”Ÿæˆä¿¡å·
signals_btc = generate_signals(bars_btc, config)
signals_eth = generate_signals(bars_eth, config)

# ç»„åˆå›æµ‹
equity_btc = run_backtest(bars_btc, signals_btc, config, capital=5000)
equity_eth = run_backtest(bars_eth, signals_eth, config, capital=5000)

# æ€»æƒç›Š
total_equity = equity_btc + equity_eth
```

---

### 2. åŠ¨æ€å‚æ•°ä¼˜åŒ–

```python
# æ»šåŠ¨çª—å£ä¼˜åŒ–
window_size = 252  # 1å¹´
step_size = 21     # 1ä¸ªæœˆ

for i in range(0, len(bars) - window_size, step_size):
    # è®­ç»ƒçª—å£
    train_bars = bars.iloc[i:i+window_size]

    # ä¼˜åŒ–å‚æ•°
    best_params = optimize_parameters(train_bars)

    # åº”ç”¨åˆ°ä¸‹ä¸€ä¸ªæœˆ
    test_bars = bars.iloc[i+window_size:i+window_size+step_size]
    signals = generate_signals(test_bars, best_params)
```

---

### 3. æœºå™¨å­¦ä¹ å¢å¼º

```python
from sklearn.ensemble import RandomForestClassifier

# ä½¿ç”¨ManipScoreå’ŒTSä½œä¸ºç‰¹å¾
X = bars[['ManipScore', 'TS', 'sigma', 'R_past']]
# âš ï¸ æ³¨æ„: å¦‚æœè¦é¢„æµ‹æœªæ¥æ–¹å‘ï¼Œéœ€è¦ä½¿ç”¨shift(-1)å¹¶åœ¨è®­ç»ƒ/æµ‹è¯•æ—¶æ­£ç¡®åˆ†å‰²æ•°æ®
y = (bars['returns'].shift(-1) > 0).astype(int)  # ä¸‹ä¸€ä¸ªbaræ˜¯å¦ä¸Šæ¶¨

# è®­ç»ƒæ¨¡å‹ (éœ€è¦ä½¿ç”¨æ—¶é—´åºåˆ—åˆ†å‰²ï¼Œé¿å…å‰è§†åå·®)
model = RandomForestClassifier(n_estimators=100)
model.fit(X[:-1], y[:-1])  # ä¸ä½¿ç”¨æœ€åä¸€ä¸ªbarï¼ˆæ²¡æœ‰æœªæ¥æ ‡ç­¾ï¼‰

# é¢„æµ‹
prob = model.predict_proba(X)[:, 1]
signals = (prob > 0.6).astype(int)  # æ¦‚ç‡>60%æ—¶åšå¤š
```

---

## å‚è€ƒèµ„æ–™

### å­¦æœ¯è®ºæ–‡

1. **Market Microstructure**
   - O'Hara, M. (1995). Market Microstructure Theory
   - Hasbrouck, J. (2007). Empirical Market Microstructure

2. **Market Manipulation Detection**
   - Aggarwal, R., & Wu, G. (2006). Stock Market Manipulations
   - Comerton-Forde, C., & PutniÅ†Å¡, T. J. (2011). Measuring Closing Price Manipulation

3. **Quantitative Trading**
   - Chan, E. (2009). Quantitative Trading
   - Pardo, R. (2008). The Evaluation and Optimization of Trading Strategies

### åœ¨çº¿èµ„æº

1. **æ•°æ®æº**
   - Binance API: https://binance-docs.github.io/apidocs/
   - Coinbase Pro API: https://docs.pro.coinbase.com/
   - OANDA API: https://developer.oanda.com/

2. **å›æµ‹æ¡†æ¶**
   - Backtrader: https://www.backtrader.com/
   - Zipline: https://www.zipline.io/
   - VectorBT: https://vectorbt.dev/

3. **æŠ€æœ¯æŒ‡æ ‡åº“**
   - TA-Lib: https://ta-lib.org/
   - Pandas-TA: https://github.com/twopirllc/pandas-ta

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2025-11-16
**ä½œè€…**: Market Manipulation Strategy Research Team
**è”ç³»**: å¦‚æœ‰é—®é¢˜ï¼Œè¯·å‚è€ƒä»£ç åº“ä¸­çš„ç¤ºä¾‹

